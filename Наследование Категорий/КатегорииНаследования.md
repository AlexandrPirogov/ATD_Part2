
1) Наследование подтипов
Имеется базовый класс "Монитор" с методом "отображать картинку()"
Имеется производный класс "Игровой монитор" и Проивзодный класс "Офисный монтиор".

2) Наследование со специализацией
Имеется базовый класс "Письменный прибор"
Имеются производные классы "Фломастер" "Карандаш" "Ручка"... И специализацию методов будет заключаться в области применения (где и чем можно писать).
P.S Правда не представляю как реализаовать пододбное пока что

3) Наследование с расширением
Базовый класс "Техника", имеет методы "включиться()" и "выключиться()"
Расширением класса "Техника" может быть класс "Музыкальный плеер" с методом "проигрывать песню", неприменимую к базовому классу "Техника". (Зависит, конечно от контекста)

4) Наследование вариаций
```cpp
class Person 
{
    public:
        void attack();
        void heal(int points);
};

void Person::attack()
{
   std::cout << "Person attacks\n";
};

void heal(int points)
{
  std::cout << "Person heals himself on " << points << " points\n";  
};

class Ork : public Person
{
 public:
    void attack();
};

//Переопределение метода родителоьского класса Person
void Ork::attack() 
{
   std::cout << "Ork attacks\n"  ;
};
```

5) Наследование с конкретизацией

Имеем абстрактный класс `Vehicle`, а в производном классе `Car` определяем логику работы метода `move()`
```cpp

class Vehicle
{
  public:
      virtual void move() = 0;
};

class Car : public Vehicle
{
  public:
     void move();
};

void Car::move()
{
   std::cout << "Car moving on\n";  
};
```

6) Структурное наследование (structure inheritance)

```java
interface Paintable
{
    void paint();
}

class Vehicle implements Paintable
{
    public void move()
    {
        System.out.println("Vehicle is moving on");
    }
    
    public void paint()
    {
        System.out.println("Vehicle got a new color");
    }
}
```
